/* 为了方便写出可以被 ？？识别的product，做以下约定：
1. 小写字母开头 = 语法Symbol
2. 大写字母开头 = 词法Token
3. 单引号开头 = TokenType.ID( xxx )
4. 标点 = TokenType.XXX
*/
//1
prog        -> 'Shader' String { shader_body }
shader_body -> props subshr 
//2
props       -> 'Properties' { props_body }
            -> 
props_body  -> prop_stm props_body
            -> 
prop_stm    -> ID ( String, ReservedWord ) = prop_init
prop_init   -> Number
            -> String { }
            -> ( Number, Number, Number, Number )
//3
subshr      -> 'SubShader' { subshr_body }
subshr_body -> tags cmds passes
//4
tags        -> 'Tags' { tags_body }
tags_body   -> tag_smt tags_body
            -> 
tag_smt     -> String = String
//5
cmds        -> cmd_stm cmds
            ->
cmd_stm     -> ReservedWord ids
ids         -> ID ids
            ->
//6
passes      -> shr_pass passes
            ->
shr_pass    -> 'Pass' { pass_body }
pass_body   -> 'CGPROGRAM' cg_prog 'ENDCG'
//7 cg
cg_prog     -> cg_stms
cg_stms     -> cg_stm cg_stms
            -> 
cg_stm      -> preprocessing_stm
//8 预处理当做特殊的stm处理好了，简单点
preprocessing_stm   -> pp_if_stm 
                    -> pp_cmd
pp_if_stm   -> # 'if' ID
            -> # 'ifdef' ID
            -> # 'idndef' ID
            -> # 'elif' ID
            -> # 'else'
            -> # 'endif'
pp_cmd      -> # 'include' String
            -> # 'pragma' ids
//9 expression，C语言的简化版
primary_exp -> ID
            -> String
            -> Number
            -> ( exp )
postfix_exp -> primary_exp
            -> postfix_exp [ exp ]
            -> postfix_exp ( argument_exp_list )
            -> postfix_exp . ID
            -> postfix_exp ++
            -> postfix_exp --
argument_exp_list       -> assignment_exp argument_exp_list
                        -> 
unary_exp   -> postfix_exp
            -> ++ unary_exp
            -> -- unary_exp
            -> unary_op unary_exp
unary_op    -> +
            -> -
            -> !
            -> ~
binary_exp  -> unary_exp
            -> binary_exp binary_op unary_exp
binary_op   -> *
            -> /
            -> %
            -> +
            -> -
            -> <<
            -> >>
            -> <
            -> >
            -> <=
            -> >=
            -> ==
            -> !=
            -> &
            -> ^
            -> |
            -> &&
            -> ||
conditional_exp   -> binary_exp
                  -> binary_exp ? exp : conditional_exp
assignment_exp    -> conditional_exp
                  -> unary_exp assignment_op assignment_exp
assignment_op     -> =
                  -> *=
                  -> /=
                  -> %=
                  -> +=
                  -> -=
                  -> <<=
                  -> >>=
                  -> &=
                  -> ^=
                  -> |=
exp         -> assignment_exp
            -> exp, assignment_exp
// 10 declaration
dec               -> dec_specifiers init_dec_list ;
dec_specifiers    -> type_specifier

type_specifier    -> 'void'
                  -> 'char'
                  -> 'short'
                  -> 'int'
                  -> 'long'
                  -> 'float'
                  -> 'double'
                  -> struct_specifier
struct_specifier  -> 'struct' ID
                  -> 'struct' ID { struct_dec_list }
struct_dec_list   -> struct_dec
                  -> struct_dec_list struct_dec
struct_dec        -> type_specifier declarator_list
declarator_list   -> declarator
                  -> declarator_list , declarator
declarator        -> ID
                  -> ( declarator )
                  -> declarator [ exp ]
                  -> declarator ( parameter_list )
parameter_list    -> parameter_dec
                  -> parameter_list , parameter_dec
parameter_dec     -> dec_specifier declarator

init_dec_list     -> init_dec
                  -> init_dec_list , init_dec
init_dec          -> declarator
                  -> declarator = exp
// 11 statement
stm               -> exp_stm
                  -> compound_stm
                  -> selection_stm
                  -> iteration_stm
                  -> jump_stm
exp_stm           -> exp ;
                  -> ;
compound_stm      -> { block_item_list }
                  -> { }
block_item_list   -> block_item
                  -> block_item_list block_item
block_item        -> dec
                  -> stm
selection_stm     -> 'if' ( exp ) stm
                  -> 'if' ( exp ) stm else stm
iteration_stm     -> 'while' (exp) stm
                  -> 'do' stm 'while' (exp);
                  -> 'for' (exp; exp; exp) stm 
jump_stm          -> 'goto' ID
                  -> 'continue'
                  -> 'break'
                  -> 'return' exp ;
                  -> 'return' ;